/*
 * UART0.c
 */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <inc/tm4c123gh6pm.h>
#include <inc/hw_memmap.h>
#include <inc/hw_gpio.h>
#include <inc/hw_uart.h>
#include <inc/hw_types.h>
#include <driverlib/rom.h>
#include <driverlib/gpio.h>
#include <driverlib/pin_map.h>
#include <driverlib/sysctl.h>
#include <driverlib/interrupt.h>
#include <driverlib/uart.h>
#include <driverlib/udma.h>
#include <driverlib/timer.h>
#include <utils/uartstdio.h>
#include <utils/ustdlib.c>
#include "UART0.h"
#include "debug.h"
#include "uDMA.h"

/*
 * Variables and pointers used.
 */
static DEFINE_PERIPHERAL_INTERRUPT(UART0_Int);
static char *UART0_RxPointer;
static char *UART0_TxPointer;
static bool *dataReceived;
static bool *dataSent;

/*
 * Initialization of communication by UART/uDMA.
 *
 * \param received and sent are the address of the respective
 * address for flags.
 * \param RxBuffer is the address to the buffer that will
 * receive data.
 *
 * Initializes UART0 communication and receives pointers for
 * flags and buffer for communication purposes.
 */
void UART0Init(bool *received, bool *sent,
		char RxBuffer[]){

	/*
	 * Initialize flags for receiving message.
	 */
	UART0_RxPointer = &RxBuffer[0];
	dataReceived = received;
	*dataReceived = false;
	dataSent = sent;
	*dataSent = false;

	/*
	 * Configure UART0 pins (PA0/Rx and PA1/Tx) on TIVA.
	 * Configure it to operate even if the CPU is in sleep.
	 */
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_UART0);
	GPIOPinConfigure(GPIO_PA0_U0RX);
	GPIOPinConfigure(GPIO_PA1_U0TX);
	GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

	/*
	 * Setting UART0 clock and baud rate as 115200 bps.
	 */
	UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
	UARTStdioConfig(0, 115200, 16000000);

	/*
	 * Enabling and setting FIFO Level trigger.
	 */
	UARTFIFOEnable(UART0_BASE);
    UARTFIFOLevelSet(UART0_BASE, UART_FIFO_TX4_8, UART_FIFO_RX4_8);

	/*
	 * Enable the UART peripheral interrupts.
	 * The uDMA controller will cause an interrupt on the
	 * UART interrupt signal when a uDMA transfer is complete.
	 */
	IntEnable(INT_UART0);
	UARTIntEnable(UART0_BASE, UART_INT_RX | UART_INT_TX |
		UART_INT_DMARX | UART_INT_DMATX | UART_INT_RT);
    UARTDMAEnable(UART0_BASE, UART_DMA_RX | UART_DMA_TX);

	/*
	 * Enable the UART for operation.
	 */
	UARTEnable(UART0_BASE);

	/*
	 * Configure the uDMA operation on UART0.
	 */
	uDMAInitUART0();

	/*
	 * Enable the uDMA interface for both TX and RX channels
	 * and enable the uDMA/Rx channel for receiving.
	 * uDMA/Tx is not enabled here (uDMASendUART0) yet
	 * because there is no data to send and may cause
	 * undesirable interruption.
	 */
	uDMAReceiveUART0(UART0_RxPointer, FIFO_TRIGGER_SIZE);
}

/*
 * Interrupt handler for uDMA/UART.
 */
void UART0Interrupt(void){

	/*
	 * Obtain the status about registers interrupt.
	 */
	UART0_Int.RAW = UARTIntStatus(UART0_BASE, false);
	UART0_Int.MASKED = UARTIntStatus(UART0_BASE, true);
	UART0_Int.uDMA = uDMAIntStatus();

	/*
	 * If interrupt was generated by Rx FIFO level trigger, just
	 * set the variables and pointers, and clear interrupts.
	 */
	if(UART0_Int.uDMA & UDMA_UART0_RX){

		*dataReceived = true;
        uDMAReceiveUART0(UART0_RxPointer, FIFO_TRIGGER_SIZE);
        uDMAIntClear(UDMA_UART0_RX);
	}

	/*
	 * If interrupt was generated by Rx FIFO timeout, read the data
	 * from FIFO and store it on buffer. After it set the variables
	 * and pointers, and clear interrupts.
	 */
	if(UART0_Int.RAW & UART_INT_RT){

		uint16_t length = 0;

		while(UARTCharsAvail(UART0_BASE)){
			*UART0_RxPointer = (char) UARTCharGet(UART0_BASE);
			UART0_RxPointer++;
			length++;
		}

		/* Back to original position */
		UART0_RxPointer = UART0_RxPointer-length;

		*dataReceived = true;
		uDMAReceiveUART0(UART0_RxPointer, FIFO_TRIGGER_SIZE);
		UARTIntClear(UART0_BASE, UART_INT_RT);
	}

	/*
	 * If interrupt was generated by Tx FIFO level trigger and
	 * there is still more data to send, send it and clear the
	 * interrupt.
	 * TODO: If there is no more data to send but it was
	 * triggered, the interrupt won't be cleared.
	 */
	if((UART0_Int.uDMA & UDMA_UART0_TX)
		&& (*dataSent == false)){

		UART0_CheckAndSend();
        uDMAIntClear(UDMA_UART0_TX);
	}

	/*
	 * Clear any other interrupt on UART Interrupt
	 * Register (UARTMIS and UARTRIS).
	 */
	UARTIntClear(UART0_BASE, UART0_Int.RAW);
	UARTIntClear(UART0_BASE, UART0_Int.MASKED);
}

/*
 * Send the chosen message.
 *
 * /param TxBuffer[] is the string or concatenated message.
 */
void UART0SendMessage(char TxBuffer[]){

	UART0_TxPointer = &TxBuffer[0];
	UART0_CheckAndSend();
}

/*
 * Check the message and send the string.
 *
 * It is used inside UART0Interrupt and UART0SendMessage APIs.
 */
void UART0_CheckAndSend(void){

	uint16_t length = 0;

	while(*UART0_TxPointer != '\0'){
		UART0_TxPointer++;
		length++;
	}

	/* Back to original position */
	UART0_TxPointer = UART0_TxPointer - length;

	/*
	 * Last part to be sent.
	 * TODO: Arbitration size is not doing well with burst
	 * mode (just my theory).
	 */
	if((length < FIFO_TRIGGER_SIZE) && (length != 0)){
		*dataSent = true;
		uDMASendUART0(UART0_TxPointer, length);
		UART0_TxPointer = UART0_TxPointer + length;
	}

	if(length >= FIFO_TRIGGER_SIZE){
		uDMASendUART0(UART0_TxPointer, FIFO_TRIGGER_SIZE);
		UART0_TxPointer = UART0_TxPointer - length + FIFO_TRIGGER_SIZE;
	}
}
