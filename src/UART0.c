/*
 * UART0.c
 */

#include <stdbool.h>
#include <stdio.h>
#include <inc/tm4c123gh6pm.h>
#include <inc/hw_memmap.h>
#include <driverlib/gpio.h>
#include <driverlib/pin_map.h>
#include <driverlib/sysctl.h>
#include <driverlib/interrupt.h>
#include <driverlib/uart.h>
#include <driverlib/udma.h>
#include <utils/uartstdio.h>
#include "UART0.h"
#include "uDMA.h"

/*
 * Variables and pointers used.
 */
static DEFINE_PERIPHERAL_INTERRUPT(UART0_Int);
static char *UART0_RxPointer;
static char *UART0_TxPointer;
static bool *dataReceived;
static bool *dataSent;

/*
 * Initialization of communication by UART/uDMA.
 *
 * \param received and sent are the address of the respective
 * address for flags.
 * \param RxBuffer is the address to the buffer that will
 * receive data.
 *
 * Initializes UART0 communication and receives pointers for
 * flags and buffer for communication purposes.
 */
void UART0Init(bool *received, bool *sent,
		char RxBuffer[]){

	/*
	 * Initialize flags for receiving message.
	 */
	UART0_RxPointer = &RxBuffer[0];
	dataReceived = received;
	*dataReceived = false;
	dataSent = sent;
	*dataSent = false;

	/*
	 * Configure UART0 pins (PA0/Rx and PA1/Tx) on TIVA.
	 * Configure it to operate even if the CPU is in sleep.
	 */
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_UART0);
	GPIOPinConfigure(GPIO_PA0_U0RX);
	GPIOPinConfigure(GPIO_PA1_U0TX);
	GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

	/*
	 * Setting UART0 clock and baud rate as 115200 bps.
	 */
	UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
	UARTStdioConfig(0, 115200, 16000000);

	/*
	 * Enabling and setting FIFO Level trigger.
	 */
	UARTFIFOEnable(UART0_BASE);
    UARTFIFOLevelSet(UART0_BASE, UART_FIFO_TX4_8, UART_FIFO_RX4_8);

	/*
	 * Enable the UART peripheral interrupts.
	 * The uDMA controller will cause an interrupt on the
	 * UART interrupt signal when a uDMA transfer is complete.
	 */
	IntEnable(INT_UART0);
	UARTIntEnable(UART0_BASE, UART_INT_RX | UART_INT_TX |
		UART_INT_DMARX | UART_INT_DMATX | UART_INT_RT);
    UARTDMAEnable(UART0_BASE, UART_DMA_RX | UART_DMA_TX);

    /*
	 * Configure the uDMA operation on UART0.
	 */
	uDMAInitUART0();

	/*
	 * Enable the UART for operation.
	 */
	UARTEnable(UART0_BASE);

	/*
	 * Enable the uDMA interface for both TX and RX channels
	 * and enable the uDMA/Rx channel for receiving.
	 * uDMA/Tx is not enabled here (uDMASendUART0) yet
	 * because there is no data to send and may cause
	 * undesirable interruption.
	 */
	uDMAReceiveUART0(UART0_RxPointer, FIFO_TRIGGER_SIZE);
}

/*
 * Interrupt handler for uDMA/UART.
 * TODO: Implement treatment for other interrupt masks.
 */
void UART0Interrupt(void){

	/*
	 * Obtain the status about registers interrupt.
	 */
	UART0_Int.RAW = UARTIntStatus(UART0_BASE, false);
	UART0_Int.MASKED = UARTIntStatus(UART0_BASE, true);
	UART0_Int.uDMA = uDMAIntStatus();

	/*
	 * If an interrupt was generated by Rx FIFO level trigger, just
	 * set the variable that indicates "message received" as true
	 * and prepare the buffer for receiving next data. Clear the
	 * interrupt in the end.
	 */
	if(UART0_Int.uDMA & UDMA_UART0_RX){

		*dataReceived = true;
        uDMAReceiveUART0(UART0_RxPointer, FIFO_TRIGGER_SIZE);
        uDMAIntClear(UDMA_UART0_RX);
	}

	/*
	 * If interrupt was generated by Rx FIFO timeout, read the data
	 * from FIFO and store it on buffer. After it set the variables
	 * and pointers, and clear interrupts.
	 */
	if(UART0_Int.RAW & UART_INT_RT){

		/* Create a temporary variable.*/
		uint16_t length = 0;

		/* Read the FIFO byte by byte to clean it. */
		while(UARTCharsAvail(UART0_BASE)){
			*UART0_RxPointer = (char) UARTCharGet(UART0_BASE);
			UART0_RxPointer++;
			length++;
		}

		/* Set pointer back to original position. */
		UART0_RxPointer = UART0_RxPointer-length;

		*dataReceived = true;
		uDMAReceiveUART0(UART0_RxPointer, FIFO_TRIGGER_SIZE);
		UARTIntClear(UART0_BASE, UART_INT_RT);
	}

	/*
	 * If interrupt was generated by Tx FIFO level trigger and
	 * there is still more data to send, send it and clear the
	 * interrupt.
	 * Note that Tx FIFO will only trigger if there is less
	 * data than FIFO level trigger. Therefore,
	 * UART0_CheckAndSend won't be a recursive case.
	 */
	if((UART0_Int.uDMA & UDMA_UART0_TX)
		&& (*dataSent == false)){

		UART0_CheckAndSend();
        uDMAIntClear(UDMA_UART0_TX);
	}

	/*
	 * If interrupt was generated by Tx FIFO level trigger but
	 * there is no more data to send, just clear the interrupt.
	 */
	if(UART0_Int.uDMA & UDMA_UART0_TX) uDMAIntClear(UDMA_UART0_TX);

	/*
	 * Clear any other interrupt on UART Interrupt
	 * Register (UARTMIS and UARTRIS).
	 */
	UARTIntClear(UART0_BASE, UART0_Int.RAW);
	UARTIntClear(UART0_BASE, UART0_Int.MASKED);
}

/*
 * Send the chosen message.
 *
 * /param TxBuffer[] is the string or concatenated message.
 *
 * This function is different from UART0_CheckAndSend
 * because it is used on main.c file, differently from the
 * last that is used on UART0.c file.
 */
void UART0SendMessage(char TxBuffer[]){

	UART0_TxPointer = &TxBuffer[0];
	UART0_CheckAndSend();
}

/*
 * Check the message and send the string.
 *
 * It is used inside UART0Interrupt and UART0SendMessage APIs.
 */
void UART0_CheckAndSend(void){

	/*
	 * TODO: There is a proper function to do what I'm doing here
	 * (to just check the string length). But this logic is not
	 * applicable for Rx case (that needs to read the FIFO).
	 */
	uint16_t length = 0;

	while(*UART0_TxPointer != '\0'){
		UART0_TxPointer++;
		length++;
	}

	/* Back to original position */
	UART0_TxPointer = UART0_TxPointer - length;

	/*
	 * If there is less than FIFO_TRIGGER_SIZE to send
	 * or is the last part of a long message to be sent,
	 * set the variable that indicates "message sent"
	 * as true and send it.
	 */
	if((length <= FIFO_TRIGGER_SIZE) && (length != 0)){
		*dataSent = true;
		uDMASendUART0(UART0_TxPointer, length);
	}

	/*
	 * If there is more data than FIFO_TRIGGER_SIZE,
	 * firstly set the pointer ahead and then send the
	 * message from where the pointer was set previously.
	 * If the pointer is set after sending the data, depending
	 * on the message length, it could send twice or enter in
	 * an infinite loop of sending.
	 * Do not set "message sent" as true here.
	 */
	if(length > FIFO_TRIGGER_SIZE){
		UART0_TxPointer = UART0_TxPointer + FIFO_TRIGGER_SIZE;
		uDMASendUART0((UART0_TxPointer - FIFO_TRIGGER_SIZE),
			FIFO_TRIGGER_SIZE);
	}
}
