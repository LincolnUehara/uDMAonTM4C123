/*
 * communication.c
 *
 */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <inc/tm4c123gh6pm.h>
#include <inc/hw_memmap.h>
#include <inc/hw_gpio.h>
#include <inc/hw_uart.h>
#include <inc/hw_types.h>
#include <driverlib/rom.h>
#include <driverlib/gpio.h>
#include <driverlib/pin_map.h>
#include <driverlib/sysctl.h>
#include <driverlib/interrupt.h>
#include <driverlib/uart.h>
#include <driverlib/udma.h>
#include <driverlib/timer.h>
#include <utils/uartstdio.h>
#include <utils/ustdlib.h>
#include "communication.h"

/*
 * Variables and pointers used.
 */
DEFINE_COMMUNICATION_PERIPHERALS(intStatus);
DEFINE_COMMUNICATION_PERIPHERALS(perError);
static char bufferRx[BUFFER_SIZE]; // TODO: unsigned[?]
static char *messagePointer;
static bool *receivedMessage;

/*
 * Initialization of communication by UART/uDMA.
 */
void commInit(bool *receivedAddress, char messageBuffer[]){

	/*
	 * Initialize each peripheral and flag for receiving message.
	 */
	receivedMessage = receivedAddress;
	*receivedMessage = false;
	messagePointer = &messageBuffer[0];
	commTIMER0_Init();
	commUART_Init();
	commUDMA_Init();
}

/*
 * Initialization of UART peripheral.
 */
void commUART_Init(void){

	/*
	 * Configure UART communication on TIVA.
	 * Configure it to operate even if the CPU is in sleep.
	 * Pins PA0 (Rx) and PA1 (Tx) are used
	 */
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_UART0);
	GPIOPinConfigure(GPIO_PA0_U0RX);
	GPIOPinConfigure(GPIO_PA1_U0TX);
	GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
	UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);

	/*
	 * Setting baud rate as 115200 bps.
	 */
	UARTStdioConfig(0, 115200, 16000000);

	/*
	 * Setting FIFO Level trigger.
	 */
    UARTFIFOLevelSet(UART0_BASE, UART_FIFO_TX4_8, UART_FIFO_RX4_8);

	/*
	 * Enable the UART for operation, and Enable the UART peripheral interrupts. Note that no UART interrupts
	 * were enabled, but the uDMA controller will cause an interrupt on the
	 * UART interrupt signal when a uDMA transfer is complete.
	 */
	UARTEnable(UART0_BASE);
	IntEnable(INT_UART0);
}

/*
 * Initialization of uDMA peripheral.
 */
void commUDMA_Init(){

	/*
	 * Starting DMA Configuration.
	 */
	SysCtlPeripheralEnable(SYSCTL_PERIPH_UDMA);
	uDMAEnable();

	/*
	 * Point at the control table to use for channel control structures.
	 */
	uDMAControlBaseSet(DMAcontroltable);

	/*
	 * TODO: Check.
	 */
	uDMAChannelAssign(UDMA_CH8_UART0RX);
	uDMAChannelAssign(UDMA_CH9_UART0TX);

	/*
	 * 1 - Disable all the atributes in case any was set.
	 * 2 - Set the channel control.
	 * 3 - Set up the transfer parameters
	 * TODO: Check.
	 */
	uDMAChannelAttributeDisable(UDMA_CH8_UART0RX,
			UDMA_ATTR_ALTSELECT | UDMA_ATTR_USEBURST |
			UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK);
	uDMAChannelAttributeDisable(UDMA_CH9_UART0TX,
			UDMA_ATTR_ALTSELECT | UDMA_ATTR_HIGH_PRIORITY |
			UDMA_ATTR_REQMASK);
	uDMAChannelControlSet(UDMA_CH8_UART0RX | UDMA_PRI_SELECT,
			UDMA_SIZE_8 | UDMA_SRC_INC_NONE | UDMA_DST_INC_8 |
			UDMA_ARB_4);
	uDMAChannelControlSet(UDMA_CH9_UART0TX | UDMA_PRI_SELECT,
			UDMA_SIZE_8 | UDMA_SRC_INC_8 | UDMA_DST_INC_NONE |
			UDMA_ARB_4);
	uDMAChannelTransferSet(UDMA_CH8_UART0RX | UDMA_PRI_SELECT,
			UDMA_MODE_BASIC,(void *)(UART0_BASE + UART_O_DR),
			&bufferRx,sizeof(bufferRx));

	/*
	 * Enable the uDMA interface for both TX and RX channels.
	 * Enable the DMA channel for RX. "UDMA_CH9_UART0TX" is not
	 * enabled until main function processing.
	 */
	UARTDMAEnable(UART0_BASE, UART_DMA_RX | UART_DMA_TX);
    uDMAChannelEnable(UDMA_CH8_UART0RX);
}

/*
 * Initialization of Timer0 peripheral.
 */
void commTIMER0_Init(void){

	/*
	 * Configuring the 32-bit periodic timers.
	 */
	SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
	TimerConfigure(TIMER0_BASE, TIMER_CFG_ONE_SHOT_UP); // TODO: Check.
	TimerLoadSet(TIMER0_BASE, TIMER_A, UDMA_TIMING);

	/*
	 * Enable the Timers for timeout interrupt.
	 */
	IntEnable(INT_TIMER0A);
	TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
}

/*
 * Interrupt handler for UART and Timer.
 */
void commInterrupt(void){

	/*
	 * Obtain the status of each peripheral.
	 */
	intStatus.UART = UARTIntStatus(UART0_BASE, 1);
	intStatus.uDMA = uDMAIntStatus();
	intStatus.TIMER0 = TimerIntStatus(TIMER0_BASE, 1);

	/*
	 * Start the timer if UART/uDMA started to receive something.
	 */
	if(intStatus.UART & UART0FIFO_INTERRUPT)
		TimerEnable(TIMER0_BASE, TIMER_A);

	/*
	 * Check if interrupt was generated by Rx/uDMA or Timer0.
	 * If generated by Rx/uDMA, it means that received enough
	 * message to fill RxBuffer. If generated by Timer0, it means
	 * that received the message, but not enough to fulfill the
	 * buffer.
	 */
	if((intStatus.uDMA & UART0RX_INTERRUPT)||
	    (intStatus.TIMER0 & TIMER_TIMA_TIMEOUT)){

		/*
		 * Clear only Rx interrupt for UART0.
		 */
		uDMAIntClear(UART0RX_INTERRUPT);

		/*
		 * Disable Timer0, clear its interrupt and reset it.
		 * Only do it inside this "if" condition.
		 */
		TimerDisable(TIMER0_BASE, TIMER_A);
		TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
		HWREG(TIMER0_BASE+0x50) = 0;

		/*
		 * Transfer data to main.c variable.
		 */
		commTransferData();

		/*
		 * Enable the receiving for next message.
		 */
		uDMAChannelTransferSet(UDMA_CH8_UART0RX | UDMA_PRI_SELECT,
				UDMA_MODE_BASIC,(void *)(UART0_BASE + UART_O_DR),
				&bufferRx, sizeof(bufferRx));
		uDMAChannelEnable(UDMA_CH8_UART0RX);

		/*
		 * Enable UART interrupt. Only enable in the end because
		 * it will be the first one to be set.
		 */
		UARTIntClear(UART0_BASE, intStatus.UART);
	}

	/*
	 * For debugging purposes. "else" is not applicable here.
	 */
	if((intStatus.uDMA != UART0RX_INTERRUPT)
			&& (intStatus.TIMER0 != TIMER_TIMA_TIMEOUT)
			&& (intStatus.UART != UART0FIFO_INTERRUPT)){

		commReportBugMessage();
		UARTIntClear(UART0_BASE, intStatus.UART);
		uDMAIntClear(intStatus.uDMA);
		TimerIntClear(TIMER0_BASE, intStatus.TIMER0);
		while(1);
	}
}

/*
 * Import data and flush buffer.
 */
void commTransferData(void){

	for(int i = 0 ; i < BUFFER_SIZE ; i++){
		*messagePointer = bufferRx[i];
		messagePointer++;
	}

	*receivedMessage = true;

	for(int i = (BUFFER_SIZE-1) ; i >= 0 ; i--){
		bufferRx[i] = '\0';
		messagePointer--;
	}
}

/*
 * Report bug message and stuck.
 */
void commReportBugMessage(void){

	commDisableInterrupt();

	UARTprintf("\n Some error occurred on communication interrupt.");
	UARTprintf("UART interrupt flags: %d", intStatus.UART);
	UARTprintf("uDMA interrupt flags: %d", intStatus.uDMA);
	UARTprintf("Timer0 interrupt flags: %d", intStatus.TIMER0);
}

/*
 * Process and organize the received message.
 */
void commProcessMsg(unsigned char *message){

}

/*
 * Send a string vector of the argument.
 */
void commSendMessage(char TxMessageBuffer[], uint8_t dataLength){

	uDMAChannelTransferSet(UDMA_CH9_UART0TX | UDMA_PRI_SELECT,
	    UDMA_MODE_BASIC, TxMessageBuffer,
		(void *)(UART0_BASE + UART_O_DR), dataLength);

	uDMAChannelEnable(UDMA_CH9_UART0TX);
}

/*
 * The interrupt handler for uDMA errors. This interrupt will occur if the
 * uDMA encounters a bus error while trying to perform a transfer. This
 * handler just increments a counter if an error occurs.
 */
void commErrorHandler(void){

    if(uDMAErrorStatusGet()){

        uDMAErrorStatusClear();
        perError.uDMA++;
    }
}

/*
 * Enables UART receiver interrupt.
 */
void commEnableInterrupt(void) {

	IntEnable(INT_UART0);
	UARTIntEnable(UART0_BASE, UART_INT_TX | UART_INT_RX);
	/* TODO: Check "UART_INT_RT" */
}

/*
 * Disables UART receiver interrupt.
 */
void commDisableInterrupt(void) {

	IntDisable(INT_UART0);
	UARTIntDisable(UART0_BASE, UART_INT_RX | UART_INT_RT);
}

/*
 * Shows the report about uDMA communication.
 * TODO: Implement.
 */
void commShowReport(void){

	/*
	 * Print the result.
	 */
	char egbt_text[40]={
			"Errors on uDMA Handler:"
	};
	UARTprintf("%s \t\t%d \n", egbt_text, perError.uDMA);
}
